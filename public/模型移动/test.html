<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>å­¦ä¹ </title>
</head>

<body>
  <canvas id="c3d" class="c3d" width="1000" height="500"></canvas>
  <script type="importmap">
      {
        "imports": {
          "three": "./three.js-master/build/three.module.js"
        }
      }
    </script>
  <script type="module">
    import * as THREE from "./three.js-master/build/three.module.js";
    import { OrbitControls } from "./three.js-master/examples/jsm/controls/OrbitControls.js";
    import { FBXLoader } from "./three.js-master/examples/jsm/loaders/FBXLoader.js";

    const canvas = document.querySelector("#c3d");
    // æ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ canvas });
    // å¼€å¯é˜´å½±æ¸²æŸ“
    renderer.shadowMap.enabled = true;

    const fov = 40; // è§†é‡èŒƒå›´
    const aspect = 2; // ç›¸æœºé»˜è®¤å€¼ ç”»å¸ƒçš„å®½é«˜æ¯”
    const near = 0.1; // è¿‘å¹³é¢
    const far = 10000; // è¿œå¹³é¢
    // é€è§†æŠ•å½±ç›¸æœº
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    // camera.position.set(1000, 500, 1500)
    camera.position.set(-1000, 1000, 100);
    camera.lookAt(0, 0, 0);
    // æ§åˆ¶ç›¸æœº
    const controls = new OrbitControls(camera, canvas);
    controls.update();

    // åœºæ™¯
    const scene = new THREE.Scene();

    // èƒŒæ™¯
    scene.background = new THREE.Color(0x87ceeb);
    // é›¾
    scene.fog = new THREE.Fog(0x87ceeb, 200, 10000);

    // è¾…åŠ©
    // const axes = new THREE.AxisHelper(700)
    // scene.add(axes)

    {
      // ç¯å…‰
      const skyColor = 0xffffff; // å¤©ç©º ç™½è‰²
      const groundColor = 0x000000; // åœ°é¢ é»‘è‰²
      const intensity = 1; // å¼ºåº¦
      const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
      scene.add(light);
    }

    let dLight = null;
    {
      const light = new THREE.DirectionalLight(0xaaaaaa); // æ–¹å‘å…‰
      light.position.set(0, 200, 100); // æ–¹å‘å…‰ä½ç½®
      light.lookAt(new THREE.Vector3()); // æ–¹å‘å…‰æœå‘

      light.castShadow = true; // å¼€å¯é˜´å½±æŠ•å°„
      light.shadow.camera.top = 300; // é˜´å½±ç›¸æœºçš„ä¸Šè¾¹ç•Œ
      light.shadow.camera.bottom = -300; // é˜´å½±ç›¸æœºçš„ä¸‹è¾¹ç•Œ
      light.shadow.camera.left = -300; // é˜´å½±ç›¸æœºçš„å·¦è¾¹ç•Œ
      light.shadow.camera.right = 300; // é˜´å½±ç›¸æœºçš„å³è¾¹ç•Œ

      dLight = light;
      scene.add(light);
    }

    {
      // åœ°é¢
      const loader = new THREE.TextureLoader(); // çº¹ç†åŠ è½½å™¨
      const texture = loader.load("1.jpg");
      console.log("ğŸš€ ~ texture:", texture);
      texture.wrapS = THREE.RepeatWrapping; // çº¹ç†é‡å¤
      texture.wrapT = THREE.RepeatWrapping; // çº¹ç†é‡å¤
      texture.magFilter = THREE.NearestFilter; // çº¹ç†è¿‡æ»¤
      // çº¹ç† é‡å¤
      texture.repeat.set(100, 100);

      const planeGeo = new THREE.PlaneGeometry(10000, 10000); // å¹³é¢å‡ ä½•ä½“
      const planeMat = new THREE.MeshPhongMaterial({
        map: texture,
        side: THREE.DoubleSide,
      }); // ç½‘æ ¼æè´¨
      const mesh = new THREE.Mesh(planeGeo, planeMat);
      mesh.rotation.x = Math.PI * -0.5;
      mesh.receiveShadow = true; // å¼€å¯é˜´å½±æ¥æ”¶

      scene.add(mesh);
    }

    let meshHY = null;
    let actions = []; // æ‰€æœ‰çš„åŠ¨ç”»æ•°ç»„
    let gui = {}; // åŠ¨ç”»æ§åˆ¶
    let mixer = null; // AnimationMixer å¯¹è±¡
    const loader = new FBXLoader();
    loader.load("Naruto.fbx", function (mesh) {
      console.log("ğŸš€ ~ mesh:", mesh);
      mesh.position.y = 110;
      // è®¾ç½®æ¨¡å‹çš„æ¯ä¸ªéƒ¨ä½éƒ½å¯ä»¥æŠ•å½±
      mesh.traverse(function (child) {
        if (child.isMesh) {
          child.castShadow = true; // å¼€å¯é˜´å½±æŠ•å°„
          child.receiveShadow = true; // å¼€å¯é˜´å½±æ¥æ”¶
        }
      });

      // è®¾ç½®å…‰çº¿ç„¦ç‚¹æ¨¡å‹
      dLight.target = mesh;
      meshHY = mesh;
      scene.add(mesh);

      mixer = new THREE.AnimationMixer(mesh); // åŠ¨ç”»æ··åˆå™¨
      for (var i = 0; i < mesh.animations.length; i++) {
        actions[i] = mixer.clipAction(mesh.animations[i]);
      }
      gui["action"] = function (s) {
        for (var j = 0; j < actions.length; j++) {
          if (j === s) {
            actions[j].play();
          } else {
            actions[j].stop();
          }
        }
      };
      // ç¬¬24ä¸ªåŠ¨ä½œæ˜¯é¸£äººç«™ç«‹çš„åŠ¨ä½œ
      gui["action"](24);
    });

    let keyNum = 24; // åŠ¨ä½œ
    document.onkeydown = function (e) {
      // 32 ç©ºæ ¼é”®
      // 27 ESCé”®
      if (e && e.keyCode == 32) {
        if (keyNum === 27) {
          keyNum = 1;
        }
        keyNum += 1;
        gui["action"](keyNum);
      }
    };

    // ç›‘å¬é”®ç›˜æ˜¯å¦æŒ‰ä¸‹
    let keyCodeW = false;
    let keyCodeS = false;
    let keyCodeA = false;
    let keyCodeD = false;
    let keyCodeK = false; // æ”»å‡»
    document.addEventListener(
      "keydown",
      (e) => {
        var ev = e || window.event;
        switch (ev.keyCode) {
          case 87:
            keyCodeW = true;
            break;
          case 83:
            keyCodeS = true;
            break;
          case 65:
            keyCodeA = true;
            break;
          case 68:
            keyCodeD = true;
            break;
          case 75:
            keyCodeK = true;
            attack();
            break;
          default:
            break;
        }
      },
      false
    );
    document.addEventListener(
      "keyup",
      (e) => {
        var ev = e || window.event;
        switch (ev.keyCode) {
          case 87:
            keyCodeW = false;
            break;
          case 83:
            keyCodeS = false;
            break;
          case 65:
            keyCodeA = false;
            break;
          case 68:
            keyCodeD = false;
            break;
          default:
            break;
        }
      },
      false
    );

    // æ§åˆ¶ ç§»åŠ¨
    function onCodeMove(mesh) {
      if (keyCodeW) {
        mesh.position.x += 2;
        camera.position.x += 2;
        dLight.position.x += 2;
        mesh.rotation.y = Math.PI * 0.5;
      }
      if (keyCodeA) {
        mesh.position.z -= 2;
        camera.position.z -= 2;
        dLight.position.z -= 2;
        mesh.rotation.y = Math.PI;
      }
      if (keyCodeS) {
        mesh.position.x -= 2;
        camera.position.x -= 2;
        dLight.position.x -= 2;
        mesh.rotation.y = Math.PI * 1.5;
      }
      if (keyCodeD) {
        mesh.position.z += 2;
        camera.position.z += 2;
        dLight.position.z += 2;
        mesh.rotation.y = Math.PI * 2;
      }

      if (keyCodeW && keyCodeD) {
        mesh.rotation.y = Math.PI * 0.25;
      }
      if (keyCodeW && keyCodeA) {
        mesh.rotation.y = Math.PI * 0.75;
      }
      if (keyCodeA && keyCodeS) {
        mesh.rotation.y = Math.PI * 1.25;
      }
      if (keyCodeS && keyCodeD) {
        mesh.rotation.y = Math.PI * 1.75;
      }

      if (keyCodeK) {
      } else {
        resetMove();
      }
    }

    let moveNum = false;
    // é‡ç½®ç§»åŠ¨
    function resetMove() {
      // æŒ‰ä¸‹é”®ç›˜ è·‘æ­¥åŠ¨ç”»
      if (keyCodeW || keyCodeS || keyCodeA || keyCodeD) {
        gui["action"](3);
        moveNum = true;
      } else {
        // åªæ‰§è¡Œä¸€æ¬¡
        if (moveNum) {
          moveNum = false;
          gui["action"](24);
        }
      }
    }

    // è¸¢ 8 9 10
    let attackList = [12, 8, 9, 10]; // è¿æ‹›çš„å¾ªåº
    let attackCombo = true;
    let skills = 0; // ä¸‹æ ‡
    let clickNum = 0; // ç‚¹å‡»æ¬¡æ•°

    // æ¨¡å‹æ”»å‡»
    function attack() {
      clickNum++;
      if (attackCombo) {
        attackCombo = false;

        // æ‰§è¡Œç¬¬ä¸€ä¸ªåŠ¨ç”»
        gui["action"](attackList[skills]);
        timeCallback();
      }
    }

    function timeCallback() {
      console.log(attackCombo);
      setTimeout(function () {
        // è¿›è¡Œä¸‹ä¸€ä¸ªåŠ¨ä½œ
        skills++;
        // åˆ¤æ–­ç‚¹å‡»æ¬¡æ•°æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªåŠ¨ä½œï¼Œå¦‚æœå…¨éƒ¨åŠ¨ä½œå®Œæˆç»“æŸå¾ªç¯
        if (skills === clickNum || skills > attackList.length - 1) {
          console.log("skills", skills);
          skills = 0;
          clickNum = 0;
          attackCombo = true;
          keyCodeK = false;
          moveNum = true;
          resetMove();
        } else {
          gui["action"](attackList[skills]);
          timeCallback();
        }
      }, meshHY.animations[attackList[skills]].duration * 1000);
    }

    const clock = new THREE.Clock();
    // æ¸²æŸ“
    function render() {
      const time = clock.getDelta();
      if (mixer) {
        mixer.update(time);
      }

      if (meshHY) {
        onCodeMove(meshHY);
      }

      // controls.update()
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>

</html>